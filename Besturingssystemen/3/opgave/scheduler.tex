\documentclass[11pt,a4paper,twoside]{article}
\oddsidemargin 0.0cm
\evensidemargin 0.0cm
\textwidth 16cm
\usepackage{graphicx}
%\usepackage[dutch]{babel}
\usepackage{hyperref} 

\begin{document}
\title{Opdracht 3: scheduler}
\author{Raphael Poss \and Dick van Albada \and en vele anderen}

\maketitle

\section{Doelstellingen}

\begin{enumerate}
\setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item Het verkrijgen van inzicht in het gedrag van scheduling algoritmen.
  \item Het gebruiken van een eenvoudig simulatieprogramma.
  \item Verdere oefening in C programmeren.
  \item Oefening in het doen van metingen.
  \end{enumerate}
Deze opgave met groepjes van twee maken.

\section{Inleiding}

Zoals op college is behandeld, heeft scheduling te maken met het
toewijzen van hulpbronnen, of resources aan een proces. Sommige
hulpbronnen moeten eenmalig bij het aanmaken van het proces worden
toegewezen (je zou kunnen denken aan swapruimte op schijf, en in elk
geval een process control block), sommige tijdens de uitvoering van het
proces. Daarbij zijn dan weer resources die door het OS tijdelijk
teruggenomen kunnen worden (zoals de processor) en andere die na
toewijzing in gebruik moeten blijven tot het proces er voorlopig weer
meer klaar is (zoals I/O devices).\\
Een goede scheduling heeft een enorme invloed op de prestaties van het
systeem. Maar het hangt af van zowel de gebruikte criteria voor een
goede prestatie, als van het feitelijke werkaanbod, welk scheduling-algoritme de
beste prestaties levert. In deze opgaaf moet je voor een gegeven
systeem proberen zo goed mogelijke prestaties te bereiken. Dat gebeurt
in simulatie.\\
Simulatie vormt een prima methode om de kwaliteit van een scheduling
methode te beoordelen, met name door zijn grote flexibiliteit, herhaalbaarheid en
relatief lage kosten. Voor het bestuderen van scheduling wordt meestal
gebruik gemaakt van de een of andere vorm van ``discrete event
simulation''. Zo ook in deze opgaaf. De practicumleiding heeft een
simulatieprogramma geschreven, waar alleen de scheduler nog aan
ontbreekt. Hoewel het programma gebruik maakt van een random-generator,
is het wel zo opgezet dat bij gelijke invoer, steeds dezelfde uitvoer
wordt gegeven. \\
De simulatie kent drie soorten resources waarop een proces moet kunnen
wachten:\\
\begin{enumerate}
  \item Geheugen - eenmalig aan het begin.
  Totaal zijn er \texttt{MEM\_SIZE} (gedefini\"eerd in
  \texttt{mem\_alloc.h}) eenheden geheugen beschikbaar
(misschien stellen dat wel 8KB page frames voor). Een proces moet
voordat het kan draaien geheugen toegewezen krijgen. Dit vormt een
onderdeel van de opgave. Er is een aantal speciale functies die je
hiervoor moet gebruiken. Het gebruik hiervan wordt in een skelet voor
de uitwerking en in de header files ge\"illustreerd.
    \item CPU - herhaald. Er wordt \'e\'en processor gesimuleerd. Elk proces heeft
afwisselend de processor en een I/O device nodig. Het schedulen van de
CPU vormt een onderdeel van de opgave.
    \item Drie I/O devices - herhaald. Laat de scheduling hiervan aan de aangeboden
simulator over.
\end{enumerate}


\subsection*{De simulator}


Voor dit onderdeel is door de practicumleiding een
simulator geschreven. Deze simuleert het
draaien van processen. Hij kan zowel worden gebruikt bij het testen van
alleen de hoog-niveau scheduler (toewijzing van eenmalige resources; in
dit geval, geheugen), als voor het gezamenlijk testen van een
hoog-niveau en een CPU scheduler. De opzet van de wachtrij voor de CPU
in het programma is zo dat zonder verdere maatregelen een FCFS
scheduling wordt gebruikt, wat voor een batch systeem niet zo onlogisch
is (maar RR met een niet te korte time slice is nog logischer).

Om een volledig simulatie-programma te krijgen, moet je zelf nog scheduling-routines toevoegen.

Het programma moet uiteindelijk bestaan uit vier modules:\newline
Een versie van de simulator, aangeleverd als \texttt{simul2015.c}.
Deze bevat o.a. de main routine.\newline
Een gesimuleerde geheugentoewijzingsroutine, aangeleverd als \texttt{mem\_alloc.o}.\footnote{Omdat dit een uitwerking is van een andere opgave, die dan wel dit jaar niet wordt gebruikt, wordt deze alleen als object-file aangeboden.} \newline
Een state-of-the-art random number generator, de ``Mersenne twister'' van
Matsumoto aangeleverd als \texttt{mt19937ar.c}.\newline
Jullie eigen scheduler. Een skelet wordt aangeleverd als \texttt{scheduler-skeleton.c}.\newline

\emph{Maak geen aanpassingen in \texttt{simul2015.c} of \texttt{mt19937ar.c}, want je code wordt met 
een programma met dezelfde eigenschappen getest en zou dan mogelijk niet meer compileren of verkeerd werken.}

De benodigde sources, object files en header files kunnen jullie in ieder geval vinden
op de web site van het vak.\\
Er zijn object files beschikbaar voor Linux, Linux-64, Solaris en Cygwin.\newline
Voor alle vier is er ook een volledig werkende versie \texttt{schedsim}
beschikbaar als voorbeeld. Deze voldoet echter niet aan alle eisen en de werking ervan is niet optimaal.

De functie \texttt{schedule(event\_type event)} is nog niet
uitgewerkt. Deze moeten jullie schrijven. 

\subsection*{De schedule.h file}

De benodigde wachtrijen en typedeclaraties, zoals \texttt{event\_type},
worden beschreven in de file \texttt{schedule.h}.
Bekijk het commentaar en de code in deze file
zorgvuldig, want ze geven je extra houvast en mogelijkheden bij het
maken van de opgave.

Ieder proces wordt beschreven door een record dat deels toegankelijk
is voor het student-programma en deels (via het gebruik van een \texttt{void}
pointer) ontoegankelijk. 

Deze records staan steeds in een van de volgende vier (dubbelverbonden) lijsten: 

 \begin{description}
 \item[\textbf{Nieuwe processen}] 
  Deze wachten nog op de toewijzing van geheugen.\\    
 In het record staat de benodigde hoeveelheid geheugen.\\    
 De simulator genereert nieuwe processen en plaatst deze achteraan in de
lijst van nieuwe processen. De proces-parameters zoals
geheugengebruik, CPU en IO gebruik worden hierbij ook vastgelegd in
het ontoegankelijke deel van het record. Alleen de voor de scheduler
kenbare informatie wordt ook in het toegankelijke deel geplaatst.\\    
 De hoog-niveau scheduler kan processen uit deze rij selecteren,
geheugen toewijzen en daarna in de ready queue \texttt{ready\_proc}
plaatsen. Als de simulator een nieuw proces in de \texttt{new\_proc} rij heeft
geplaatst, roept hij de scheduler aan met een \texttt{NewProcess\_event}. 
    
     \item[\textbf{Ready processen}] 
  Het eerste proces in deze lijst wordt na terugkeer uit de
functie \texttt{schedule} uitgevoerd. Als het bij de uitvoering
I/O gaat doen, zet de simulator het proces in de I/O queue \texttt{io\_proc}
en roept \texttt{schedule} aan met een \texttt{IO\_event}.
Loopt het proces in deze time slice af, dan wordt het in de \texttt{defunct\_proc}
queue geplaatst, in afwachting van het vrijgeven van het gebruikte
geheugen. De scheduler wordt dan met een \texttt{Finish\_event}
aangeroepen.\\    
 De simulator gebruikt bij het simuleren van het CPU-gebruik een
time slice, die om een FCFS gedrag te krijgen heel groot is gemaakt,
maar die je zelf steeds met \texttt{set\_slice} op een kleinere waarde kan zetten.
Als het proces tot het eind van zijn time slice
doorrekent, blijft het proces staan waar het was (vooraan in de \texttt{ready\_proc} queue),
en wordt alleen de
gebruikte CPU-tijd verhoogd. De scheduler wordt dan met een \texttt{Time\_event}
aangeroepen, waarna hij b.v. het betreffende proces helemaal
achterin de \texttt{ready-queue} zou kunnen plaatsen en een ander geschikt proces uit de \texttt{ready-queue} selecteren en vooraan zetten.
Als er geen ready processen zijn, zal het \texttt{NULL}-proces
gaat lopen tot er een significant event optreedt (een nieuw proces, of
een proces dat zijn I/O afrondt).

     \item[\textbf{I/O}] 
  De processen in deze lijst komen vooralsnog niet voor scheduling
in aanmerking. De simulator plaatst ze naar verloop van tijd terug naar
de ready queue en roept dan de scheduler met een \texttt{Ready\_event}
aan.
    
     \item[\textbf{Defunct}] 
  De processen in deze lijst zijn klaar, maar hebben nog geheugen
bezet. Dit moet worden vrijgegeven, waarna de functie \texttt{rm\_process(proces)}
kan worden aangeroepen om het record te verwijderen en statistische
gegeven te verzamelen. 
\end{description}

 

 Naast de boven beschreven zaken zijn er nog een functie en twee
functie-pointers gedefini\"eerd: 
\begin{description}
  \item[\textbf{finale}] 
  Finale is een functie variabele die wijst naar een parameter-loze
void functie die door de simulator helemaal aan het eind wordt
aangeroepen. Door deze functie-variabele naar een eigen functie te
laten
verwijzen kan je b.v. door jezelf verzamelde statistische informatie
laten afdrukken. 
  \item[\textbf{reset\_stats}] 
  \texttt{Reset\_stats} is een functie variabele die wijst naar een
parameter-loze
void functie die door de simulator wordt
aangeroepen op het moment dat de eigenlijke meting start. Hij kan
worden gebruikt om allerlei tellers op nul te zetten na de aanloopfase
van de simulatie. Door deze functie-variabele naar een eigen functie te
laten
verwijzen kan je b.v. door jezelf verzamelde statistische informatie
ook op dat moment resetten. Vergeet dan niet ook de oorspronkelijke \texttt{reset\_stats}
vanuit je eigen functie aan te roepen om de tellers in de aangeleverde code 
weer op nul te zetten.
  \item[\textbf{set\_slice(double slice)}] 
  Met deze functie kan je zorgen dat de simulator na \texttt{slice}
  gesimuleerde tijdseenheden een \texttt{Time\_event} genereert.
Hiermee kan je b.v. round-robin CPU scheduling realiseren. Een
dergelijke scheduler kan een
interessant effect op de performance hebben. Deze functie heb je nodig
als je een pre\"emptieve CPU-scheduler wil maken.\\
Let op - deze functie heeft alleen effect op de eerstvolgende slice. \emph{Daarna wordt de lengte van de time-slice weer op een hele grote waarde teruggezet.}
  \end{description}
  
\subsection*{De feitelijke opdracht}

De bedoeling van de opdracht is dat je twee scheduling-algoritmen implementeert -- een hoog-niveau scheduler
die geheugen aan een proces toewijst en daarmee de uitvoering van dat proces initi\"eert, en een CPU 
scheduler die regelt welk proces het eerst op de CPU mag. Samen bepalen ze hoe lang processen op uitvoering
moeten wachten en hoe snel ze daarna worden uitgevoerd.
Het derde deel van de opdracht is dan ook dat je het gedrag van je systeem bij verschillende belastingen en 
verschillende instellingen van de schedulers onderzoekt.

\subsubsection*{De hoog-niveau scheduler}


Elk proces in de wachtrij voor nieuwe processen vraagt een bepaalde
hoeveelheid geheugen aan. Pas als die (eenmalig) is toegewezen, kan het
proces beginnen met executeren. In het programma-skelet staat duidelijk
aangegeven hoe die toewijzing in zijn werk gaat. Voor het implementeren
van de hoog-niveau scheduler, hoeft je scheduler alleen iets met een `\texttt{NewProcess\_event}'
en met een `\texttt{Finish\_event}' te doen. Bij de drie andere events
kan je meteen teruggaan naar de simulator. 

 Een van de problemen waarmee de hoog-niveau scheduler te maken kan
krijgen is starvation. Processen die veel geheugen-ruimte nodig hebben
moeten wachten tot er voldoende aaneengesloten ruimte beschikbaar is. 

 Het kan nodig zijn met de scheduling van kleine processen te
wachten
om voldoende geheugen vrij te krijgen. Anderzijds, kan dit wachten
aanleiding geven tot een slechte CPU bezetting en een slechte
throughput.

Probeer iets dergelijks: zolang je de onderlinge volgorde van de processen
in de \texttt{new\_proc} queue niet verandert, staat het oudste proces vooraan en het
nieuwste achteraan. Probeer geheugen toe te wijzen aan het eerste proces in de rij. Lukt dat,
herhaal dat dan met het volgende proces in de rij, tot er geen processen meer wachten op 
geheugentoewijzing, of tot een aanvraag wordt geweigerd. Probeer na de eerste geweigerde aanvraag
nog hooguit aan $N_{try}$ volgende processen in de rij geheugen toe te wijzen. $N_{try}$ is een 
instelbare parameter van je scheduler. Zo wijs je eerst aan zoveel mogelijk processen geheugen toe,
maar loopt de kop van de rij langzamerhand vol met processen met grote aanvragen die niet kunnen
worden gehonoreerd. Op dat moment gaat het vrijgeven van geheugen domineren en is er op een ogenblik
voldoende (aaneengesloten) geheugen vrij om het eerst wachtende proces toch een plekje te geven.

Je hoeft niet precies de bovenstaande benadering te kiezen, zolang je de volgende zaken realiseert:
\begin{itemize}
\item Je begint steeds vooraan de wachtrij met toewijzen. Als het lukt geheugen toe te wijzen, probeer je dat ook voor het volgende proces.
\item Zet een proces waaraan je net geheugen hebt toegewezen helemaal achteraan in de \texttt{ready\_proc} rij.
\item Als het toewijzen mislukt, probeer je volgens een zelf te kiezen criterium nog een beperkt aantal andere processen geheugen te geven. Je kan dat b.v. doen op basis van het volgnummer in de wachtrij, of van het procesnummer.
\item Het aantal processen waarvoor je dit probeert moet een instelbare parameter zijn.
\end{itemize}

Schrijf eerst een dergelijke geheugen-scheduler en experimenteer met verschillende waarden voor 
$N_{try}$ om het effect daarvan op de prestaties te bestuderen. Het zal duidelijk zijn dat als
$N_{try}$ groot is, het erg lang kan duren voor een grote aanvraag wordt gehonoreerd (dus sommige processen zullen lang op geheugentoewijzing moeten wachten), maar anderzijds worden er maximaal veel processen 
toegelaten en zal de systeembenutting i.h.a. hoog zijn. Lees $N_{try}$ bij de start van je programma 
in van je invoer, zodat je niet steeds opnieuw hoeft te compileren.\\
Let bij je experiment in ieder geval op het aantal processen dat verwerkt kan worden en op de maximale wachttijd op geheugentoewijzing. Zolang je niets aan de CPU scheduler doet, zal die als een FCFS scheduler werken.

\subsubsection*{De CPU scheduler}

De CPU scheduler heeft in principe twee handvatten om de volgorde van
executie van processen te sturen:
\begin{enumerate}  \item Het vooraan in de ready queue plaatsen van het te executeren
proces.
  \item Het zetten van een time-slice voor deze beurt op de CPU van dat
proces.
\end{enumerate}
Je zou in principe kunnen experimenteren met round-robin scheduling, maar ook
met b.v. shortest job first, of multi-level queues of b.v. iets met prioriteiten. De gesimuleerde processen
horen een redelijk consistent gedrag te vertonen, waarbij de lengte van
de CPU burst per proces niet te veel varieert, zodat je voor SJF inderdaad een redelijke schatting van de lengte van de volgende CPU-burst moet kunnen maken.

In dit geval is het echter de bedoeling dat je wat anders probeert. Je merkt dat het beschikbare geheugen het aantal processen dat tegelijkertijd actief kan zijn beperkt. Het kan dus aantrekkelijk zijn om een
proces dat veel geheugen toegewezen heeft gekregen, ook weer zo snel mogelijk af te ronden. Maak dus een scheduler die steeds het proces dat het meeste geheugen in gebruik heeft selecteert (uit de ready queue) en vooraan in die queue zet.

Je kan ook verder gaan met je onderzoek aan de scheduler en kijken of je taken prioriteiten kan
geven op basis van andere eigenschappen en daarmee de throughput verder verhogen zonder dat je bepaalde
taken helemaal uitsluit.

Om dit te kunnen doen moet je mogelijk over elke job wat meer onthouden dan de
\texttt{{}"{}}pcb\texttt{{}"{}} datastructuur je normaal toestaat. Gebruik daarvoor een zelf te
defini\"eren structure waar je de \texttt{your\_admin} pointer naar laat wijzen. Omdat je hier in eerste instantie 
met void pointers werkt, kan dat wat ingewikkelder zijn.
Vergeet niet een en ander weer netjes op te ruimen bij het be\"eindigen
van de job.

\subsubsection*{Vertalen en linken}

Je kan je programma b.v. vertalen met: 
\begin{verbatim} > gcc -Wall -ansi -O2 -o schedule schedule.c mem_alloc.o simul2015.c mt19937ar.c -lm
\end{verbatim}
maar zorg voor een makefile.


\subsubsection*{Performance metingen}

Het simulatieprogramma staat je toe apart een belasting van het
geheugen, van de CPU en van het IO systeem in te stellen. Deze kloppen
in praktijk ongeveer, maar hangen b.v. ook van de kwaliteit van je
scheduler af.


Test je hoog-niveau en een CPU-schedulers met een
test-set van 10000 processen en belastingen van 0.75 voor geheugen, CPU
en IO. Kijk hoe goed ze de volgende doelstellingen realiseren:
\begin{itemize}  \item Er worden zoveel mogelijk processen afgerond (gaat makkelijk als
je kleine processen voorrang geeft)
    \item De maximale turn-around tijd is niet te hoog (maar ook weer niet
te veel voorrang).
\end{itemize}

Bestudeer het gedrag van je scheduler
ook voor een aantal belastingen tussen 0.6 en 0.8.

 Bij welke belasting krijg je steeds verder groeiende wachtrijen (met
 name voor geheugentoewijzing)? Je kan een binaire zoekstrategie
 gebruiken om deze
 belasting te vinden. Hoe hoger deze ligt,
 hoe beter je scheduler is.
 
\subsection*{Beoordeling}
Voor de hoog-niveau scheduler moet je minimaal de bovenbeschreven
geheugen-toewijzing correct en netjes implementeren. Als je dat correct doet, en wat experimenten
kan laten zien en het resultaat uitleggen, heb je al een voldoende verdiend.\newline
Voor een goede beoordeling moet in elk geval naast de bovengenoemde hoog-niveau scheduler ook een
CPU scheduler zijn gebouwd en beproefd.
Een goede CPU scheduler zorgt dat zowel de CPU als de I/O devices effici\"ent worden gebruikt en
liefst ook dat andere resources, zoals geheugen niet te lang door een proces bezet worden gehouden.
Een eerste stap naar zo'n scheduler kan het gebruik van een Round-Robin (RR) scheduler zijn.

Voor `zeer goed' moet je ook een slimme CPU scheduler hebben ge\"{i}mplementeerd en de performance
hebben onderzocht.

Verbetert het gedrag van je systeem vergeleken met een systeem met een
eenvoudige CPU scheduler? Hoeveel? Hoe is de verdeling van
het zoet en het zuur (om eens het politieke lingo te gebruiken)?


\subsection*{Nakijken en Inleveren}

Hoewel je geen uitgebreid verslag hoeft in te leveren, is het verstandig voor jezelf je bevindingen in een kort verslag te beschrijven.
Denk b.v. aan een paar grafiekjes met het aantal verwerkte jobs bij verschillende systeembelastingen en voor verschillende schedulers of scheduling parameters.
Geef daarin ook de overwegingen voor het gekozen ontwerp voor je scheduler. Gebruik dit verslag
als een handleiding bij het presenteren van je resultaten aan de assistent.
Lever je scheduler code plus het verslagje (pdf) in als aangegeven op de inlever pagina. 
  

\end{document}
