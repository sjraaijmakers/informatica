
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDeclaration (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundec) ||
	      (NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_id) ||
	      (NODE_TYPE (arg_node) == N_int) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_ternary));
  return (res);
}

static bool
isLocalFunVar (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_vardec));
  return (res);
}

static bool
isStatement (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_ifelse) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isDeclaration (NULL);
  isExpr (NULL);
  isLocalFunVar (NULL);
  isStatement (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_ID (arg_node), arg_node,
		   "mandatory son ASSIGN_ID is NULL");
      if (ASSIGN_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_ID (arg_node), arg_node,
		   "attribute ASSIGN_ID must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_ID (arg_node) != NULL)
    {
      ASSIGN_ID (arg_node) = TRAVdo (ASSIGN_ID (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Block node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKblock");

/*
 * Son check: BLOCK_STATEMENTS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BLOCK_STATEMENTS (arg_node), arg_node,
		   "mandatory son BLOCK_STATEMENTS is NULL");
      if (BLOCK_STATEMENTS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (BLOCK_STATEMENTS (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BLOCK_STATEMENTS hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (BLOCK_STATEMENTS (arg_node), arg_node,
		   "attribute BLOCK_STATEMENTS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BLOCK_STATEMENTS (arg_node) != NULL)
    {
      BLOCK_STATEMENTS (arg_node) =
	TRAVdo (BLOCK_STATEMENTS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPR (arg_node), arg_node,
		   "mandatory son CAST_EXPR is NULL");
      if (CAST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (CAST_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPR (arg_node), arg_node,
		   "attribute CAST_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPR (arg_node) != NULL)
    {
      CAST_EXPR (arg_node) = TRAVdo (CAST_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdeclarations (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdeclarations");

/*
 * Son check: DECLARATIONS_DECLARATION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "mandatory son DECLARATIONS_DECLARATION is NULL");
      if (DECLARATIONS_DECLARATION (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (isDeclaration (DECLARATIONS_DECLARATION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECLARATION hasnt the right type."
					 " It should be: "
					 "Nodeset: Declaration");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "attribute DECLARATIONS_DECLARATION must be NULL");
    }

/*
 * Son check: DECLARATIONS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLARATIONS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECLARATIONS_NEXT (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_NEXT hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_NEXT (arg_node), arg_node,
		   "attribute DECLARATIONS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECLARATION (arg_node) != NULL)
    {
      DECLARATIONS_DECLARATION (arg_node) =
	TRAVdo (DECLARATIONS_DECLARATION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_NEXT (arg_node) != NULL)
    {
      DECLARATIONS_NEXT (arg_node) =
	TRAVdo (DECLARATIONS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_BLOCK (arg_node), arg_node,
		   "mandatory son DOWHILE_BLOCK is NULL");
      if (DOWHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILE_BLOCK (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BLOCK hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BLOCK (arg_node), arg_node,
		   "attribute DOWHILE_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_EXPR (arg_node), arg_node,
		   "mandatory son DOWHILE_EXPR is NULL");
      if (DOWHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_EXPR (arg_node), arg_node,
		   "attribute DOWHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BLOCK (arg_node) != NULL)
    {
      DOWHILE_BLOCK (arg_node) = TRAVdo (DOWHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_EXPR (arg_node) != NULL)
    {
      DOWHILE_EXPR (arg_node) = TRAVdo (DOWHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprs");

/*
 * Son check: EXPRS_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRS_EXPR (arg_node), arg_node,
		   "mandatory son EXPRS_EXPR is NULL");
      if (EXPRS_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRS_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_EXPR (arg_node), arg_node,
		   "attribute EXPRS_EXPR must be NULL");
    }

/*
 * Son check: EXPRS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (EXPRS_NEXT (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_NEXT hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_NEXT (arg_node), arg_node,
		   "attribute EXPRS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_EXPR (arg_node) != NULL)
    {
      EXPRS_EXPR (arg_node) = TRAVdo (EXPRS_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_NEXT (arg_node) != NULL)
    {
      EXPRS_NEXT (arg_node) = TRAVdo (EXPRS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_BLOCK (arg_node), arg_node,
		   "mandatory son FOR_BLOCK is NULL");
      if (FOR_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_BLOCK (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BLOCK hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BLOCK (arg_node), arg_node,
		   "attribute FOR_BLOCK must be NULL");
    }

/*
 * Son check: FOR_ENDEXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_ENDEXPR (arg_node), arg_node,
		   "mandatory son FOR_ENDEXPR is NULL");
      if (FOR_ENDEXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_ENDEXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_ENDEXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_ENDEXPR (arg_node), arg_node,
		   "attribute FOR_ENDEXPR must be NULL");
    }

/*
 * Son check: FOR_STARTEXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_STARTEXPR (arg_node), arg_node,
		   "mandatory son FOR_STARTEXPR is NULL");
      if (FOR_STARTEXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STARTEXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STARTEXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STARTEXPR (arg_node), arg_node,
		   "attribute FOR_STARTEXPR must be NULL");
    }

/*
 * Son check: FOR_STEPEXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_STEPEXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STEPEXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STEPEXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STEPEXPR (arg_node), arg_node,
		   "attribute FOR_STEPEXPR must be NULL");
    }

/*
 * Attribute check: FOR_COUNTERNAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FOR_COUNTERNAME (arg_node), arg_node,
			 "mandatory attribute FOR_COUNTERNAME is NULL");
    }
  else
    {
      CHKnotExist (FOR_COUNTERNAME (arg_node), arg_node,
		   "attribute FOR_COUNTERNAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BLOCK (arg_node) != NULL)
    {
      FOR_BLOCK (arg_node) = TRAVdo (FOR_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_ENDEXPR (arg_node) != NULL)
    {
      FOR_ENDEXPR (arg_node) = TRAVdo (FOR_ENDEXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STARTEXPR (arg_node) != NULL)
    {
      FOR_STARTEXPR (arg_node) = TRAVdo (FOR_STARTEXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STEPEXPR (arg_node) != NULL)
    {
      FOR_STEPEXPR (arg_node) = TRAVdo (FOR_STEPEXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_LOCALFUNVARS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_LOCALFUNVARS (arg_node) != NULL)
	{
	  if (!((FALSE) || (isLocalFunVar (FUNBODY_LOCALFUNVARS (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_LOCALFUNVARS hasnt the right type."
					 " It should be: "
					 "Nodeset: LocalFunVar");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_LOCALFUNVARS (arg_node), arg_node,
		   "attribute FUNBODY_LOCALFUNVARS must be NULL");
    }

/*
 * Son check: FUNBODY_STATEMENTS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_STATEMENTS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_STATEMENTS (arg_node)) ==
		   N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STATEMENTS hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STATEMENTS (arg_node), arg_node,
		   "attribute FUNBODY_STATEMENTS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_LOCALFUNVARS (arg_node) != NULL)
    {
      FUNBODY_LOCALFUNVARS (arg_node) =
	TRAVdo (FUNBODY_LOCALFUNVARS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STATEMENTS (arg_node) != NULL)
    {
      FUNBODY_STATEMENTS (arg_node) =
	TRAVdo (FUNBODY_STATEMENTS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNCALL_PARAMS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_PARAMS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_PARAMS (arg_node), arg_node,
		   "attribute FUNCALL_PARAMS must be NULL");
    }

/*
 * Attribute check: FUNCALL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNCALL_NAME (arg_node), arg_node,
			 "mandatory attribute FUNCALL_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNCALL_NAME (arg_node), arg_node,
		   "attribute FUNCALL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_PARAMS (arg_node) != NULL)
    {
      FUNCALL_PARAMS (arg_node) =
	TRAVdo (FUNCALL_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundec");

/*
 * Son check: FUNDEC_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEC_FUNHEADER is NULL");
      if (FUNDEC_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEC_FUNHEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_FUNHEADER (arg_node) != NULL)
    {
      FUNDEC_FUNHEADER (arg_node) =
	TRAVdo (FUNDEC_FUNHEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_FUNBODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNBODY (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNBODY is NULL");
      if (FUNDEF_FUNBODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNBODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNBODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNBODY (arg_node), arg_node,
		   "attribute FUNDEF_FUNBODY must be NULL");
    }

/*
 * Son check: FUNDEF_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNHEADER is NULL");
      if (FUNDEF_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEF_FUNHEADER must be NULL");
    }

/*
 * Son check: FUNDEF_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isLocalFunVar (FUNDEF_NEXT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_NEXT hasnt the right type."
					 " It should be: "
					 "Nodeset: LocalFunVar");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_NEXT (arg_node), arg_node,
		   "attribute FUNDEF_NEXT must be NULL");
    }

/*
 * Attribute check: FUNDEF_SYMBOLTABLE
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (FUNDEF_SYMBOLTABLE (arg_node), arg_node,
		   "attribute FUNDEF_SYMBOLTABLE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNBODY (arg_node) != NULL)
    {
      FUNDEF_FUNBODY (arg_node) =
	TRAVdo (FUNDEF_FUNBODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNHEADER (arg_node) != NULL)
    {
      FUNDEF_FUNHEADER (arg_node) =
	TRAVdo (FUNDEF_FUNHEADER (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_NEXT (arg_node) != NULL)
    {
      FUNDEF_NEXT (arg_node) = TRAVdo (FUNDEF_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunheader (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunheader");

/*
 * Son check: FUNHEADER_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNHEADER_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_PARAMS (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_PARAMS hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_PARAMS (arg_node), arg_node,
		   "attribute FUNHEADER_PARAMS must be NULL");
    }

/*
 * Attribute check: FUNHEADER_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNHEADER_NAME (arg_node), arg_node,
			 "mandatory attribute FUNHEADER_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNHEADER_NAME (arg_node), arg_node,
		   "attribute FUNHEADER_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_PARAMS (arg_node) != NULL)
    {
      FUNHEADER_PARAMS (arg_node) =
	TRAVdo (FUNHEADER_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Attribute check: GLOBALDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEC_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBALDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEC_NAME (arg_node), arg_node,
		   "attribute GLOBALDEC_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPR (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPR must be NULL");
    }

/*
 * Attribute check: GLOBALDEF_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEF_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBALDEF_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEF_NAME (arg_node), arg_node,
		   "attribute GLOBALDEF_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPR (arg_node) != NULL)
    {
      GLOBALDEF_EXPR (arg_node) =
	TRAVdo (GLOBALDEF_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKid
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Id node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKid (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKid");

/*
 * Attribute check: ID_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ID_NAME (arg_node), arg_node,
			 "mandatory attribute ID_NAME is NULL");
    }
  else
    {
      CHKnotExist (ID_NAME (arg_node), arg_node,
		   "attribute ID_NAME must be NULL");
    }

/*
 * Attribute check: ID_SYMBOLTABLE
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (ID_SYMBOLTABLE (arg_node), arg_node,
		   "attribute ID_SYMBOLTABLE must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKifelse
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfElse node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKifelse (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKifelse");

/*
 * Son check: IFELSE_ELSEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (IFELSE_ELSEBLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (IFELSE_ELSEBLOCK (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_ELSEBLOCK hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_ELSEBLOCK (arg_node), arg_node,
		   "attribute IFELSE_ELSEBLOCK must be NULL");
    }

/*
 * Son check: IFELSE_IFBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFELSE_IFBLOCK (arg_node), arg_node,
		   "mandatory son IFELSE_IFBLOCK is NULL");
      if (IFELSE_IFBLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (IFELSE_IFBLOCK (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_IFBLOCK hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_IFBLOCK (arg_node), arg_node,
		   "attribute IFELSE_IFBLOCK must be NULL");
    }

/*
 * Son check: IFELSE_IFEXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFELSE_IFEXPR (arg_node), arg_node,
		   "mandatory son IFELSE_IFEXPR is NULL");
      if (IFELSE_IFEXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IFELSE_IFEXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_IFEXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_IFEXPR (arg_node), arg_node,
		   "attribute IFELSE_IFEXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_ELSEBLOCK (arg_node) != NULL)
    {
      IFELSE_ELSEBLOCK (arg_node) =
	TRAVdo (IFELSE_ELSEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_IFBLOCK (arg_node) != NULL)
    {
      IFELSE_IFBLOCK (arg_node) =
	TRAVdo (IFELSE_IFBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_IFEXPR (arg_node) != NULL)
    {
      IFELSE_IFEXPR (arg_node) = TRAVdo (IFELSE_IFEXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKint
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Int node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKint (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKint");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_EXPR (arg_node), arg_node,
		   "mandatory son MONOP_EXPR is NULL");
      if (MONOP_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_EXPR (arg_node), arg_node,
		   "attribute MONOP_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_EXPR (arg_node) != NULL)
    {
      MONOP_EXPR (arg_node) = TRAVdo (MONOP_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAM_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_NEXT (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_NEXT hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_NEXT (arg_node), arg_node,
		   "attribute PARAM_NEXT must be NULL");
    }

/*
 * Attribute check: PARAM_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (PARAM_NAME (arg_node), arg_node,
			 "mandatory attribute PARAM_NAME is NULL");
    }
  else
    {
      CHKnotExist (PARAM_NAME (arg_node), arg_node,
		   "attribute PARAM_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_NEXT (arg_node) != NULL)
    {
      PARAM_NEXT (arg_node) = TRAVdo (PARAM_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "mandatory son PROGRAM_DECLARATIONS is NULL");
      if (PROGRAM_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_DECLARATIONS (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_DECLARATIONS hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "attribute PROGRAM_DECLARATIONS must be NULL");
    }

/*
 * Attribute check: PROGRAM_SYMBOLTABLE
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (PROGRAM_SYMBOLTABLE (arg_node), arg_node,
		   "attribute PROGRAM_SYMBOLTABLE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_DECLARATIONS (arg_node) != NULL)
    {
      PROGRAM_DECLARATIONS (arg_node) =
	TRAVdo (PROGRAM_DECLARATIONS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_RETVALUE 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_RETVALUE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_RETVALUE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_RETVALUE hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_RETVALUE (arg_node), arg_node,
		   "attribute RETURN_RETVALUE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_RETVALUE (arg_node) != NULL)
    {
      RETURN_RETVALUE (arg_node) =
	TRAVdo (RETURN_RETVALUE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstatements
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Statements node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstatements (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstatements");

/*
 * Son check: STATEMENTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STATEMENTS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (STATEMENTS_NEXT (arg_node)) == N_statements)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTS_NEXT hasnt the right type."
					 " It should be: " "N_statements");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTS_NEXT (arg_node), arg_node,
		   "attribute STATEMENTS_NEXT must be NULL");
    }

/*
 * Son check: STATEMENTS_STATEMENT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STATEMENTS_STATEMENT (arg_node), arg_node,
		   "mandatory son STATEMENTS_STATEMENT is NULL");
      if (STATEMENTS_STATEMENT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStatement (STATEMENTS_STATEMENT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTS_STATEMENT hasnt the right type."
					 " It should be: "
					 "Nodeset: Statement");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTS_STATEMENT (arg_node), arg_node,
		   "attribute STATEMENTS_STATEMENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTS_NEXT (arg_node) != NULL)
    {
      STATEMENTS_NEXT (arg_node) =
	TRAVdo (STATEMENTS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTS_STATEMENT (arg_node) != NULL)
    {
      STATEMENTS_STATEMENT (arg_node) =
	TRAVdo (STATEMENTS_STATEMENT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltable
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTable node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltable (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltable");

/*
 * Son check: SYMBOLTABLE_ENTRIES 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (SYMBOLTABLE_ENTRIES (arg_node), arg_node,
		   "mandatory son SYMBOLTABLE_ENTRIES is NULL");
      if (SYMBOLTABLE_ENTRIES (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLE_ENTRIES (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLE_ENTRIES hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_ENTRIES (arg_node), arg_node,
		   "attribute SYMBOLTABLE_ENTRIES must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLE_PARENT
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOLTABLE_PARENT (arg_node), arg_node,
			 "mandatory attribute SYMBOLTABLE_PARENT is NULL");
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_PARENT (arg_node), arg_node,
		   "attribute SYMBOLTABLE_PARENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLE_ENTRIES (arg_node) != NULL)
    {
      SYMBOLTABLE_ENTRIES (arg_node) =
	TRAVdo (SYMBOLTABLE_ENTRIES (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltableentry (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltableentry");

/*
 * Son check: SYMBOLTABLEENTRY_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLEENTRY_NEXT (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLEENTRY_NEXT hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NEXT (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NEXT must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
			 "mandatory attribute SYMBOLTABLEENTRY_NAME is NULL");
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NAME must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_PARAMS
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_PARAMS (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_PARAMS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
    {
      SYMBOLTABLEENTRY_NEXT (arg_node) =
	TRAVdo (SYMBOLTABLEENTRY_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKternary
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Ternary node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKternary (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKternary");

/*
 * Son check: TERNARY_ELSE 
 */
  if ((FALSE) || (TRUE))
    {
      if (TERNARY_ELSE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (TERNARY_ELSE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "TERNARY_ELSE hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (TERNARY_ELSE (arg_node), arg_node,
		   "attribute TERNARY_ELSE must be NULL");
    }

/*
 * Son check: TERNARY_PRED 
 */
  if ((FALSE) || (TRUE))
    {
      if (TERNARY_PRED (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (TERNARY_PRED (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "TERNARY_PRED hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (TERNARY_PRED (arg_node), arg_node,
		   "attribute TERNARY_PRED must be NULL");
    }

/*
 * Son check: TERNARY_THEN 
 */
  if ((FALSE) || (TRUE))
    {
      if (TERNARY_THEN (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (TERNARY_THEN (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "TERNARY_THEN hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (TERNARY_THEN (arg_node), arg_node,
		   "attribute TERNARY_THEN must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (TERNARY_ELSE (arg_node) != NULL)
    {
      TERNARY_ELSE (arg_node) = TRAVdo (TERNARY_ELSE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (TERNARY_PRED (arg_node) != NULL)
    {
      TERNARY_PRED (arg_node) = TRAVdo (TERNARY_PRED (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (TERNARY_THEN (arg_node) != NULL)
    {
      TERNARY_THEN (arg_node) = TRAVdo (TERNARY_THEN (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDEC_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_EXPR (arg_node), arg_node,
		   "attribute VARDEC_EXPR must be NULL");
    }

/*
 * Son check: VARDEC_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isLocalFunVar (VARDEC_NEXT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_NEXT hasnt the right type."
					 " It should be: "
					 "Nodeset: LocalFunVar");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_NEXT (arg_node), arg_node,
		   "attribute VARDEC_NEXT must be NULL");
    }

/*
 * Attribute check: VARDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARDEC_NAME (arg_node), arg_node,
			 "mandatory attribute VARDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARDEC_NAME (arg_node), arg_node,
		   "attribute VARDEC_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_EXPR (arg_node) != NULL)
    {
      VARDEC_EXPR (arg_node) = TRAVdo (VARDEC_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_NEXT (arg_node) != NULL)
    {
      VARDEC_NEXT (arg_node) = TRAVdo (VARDEC_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_BLOCK (arg_node), arg_node,
		   "mandatory son WHILE_BLOCK is NULL");
      if (WHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (WHILE_BLOCK (arg_node)) == N_block)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BLOCK hasnt the right type."
					 " It should be: " "N_block");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BLOCK (arg_node), arg_node,
		   "attribute WHILE_BLOCK must be NULL");
    }

/*
 * Son check: WHILE_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_EXPR (arg_node), arg_node,
		   "mandatory son WHILE_EXPR is NULL");
      if (WHILE_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILE_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_EXPR (arg_node), arg_node,
		   "attribute WHILE_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BLOCK (arg_node) != NULL)
    {
      WHILE_BLOCK (arg_node) = TRAVdo (WHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_EXPR (arg_node) != NULL)
    {
      WHILE_EXPR (arg_node) = TRAVdo (WHILE_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_cast_type,
  CHK_error_message,
  CHK_float_value,
  CHK_for_countername,
  CHK_funcall_name,
  CHK_fundef_export,
  CHK_funheader_name,
  CHK_globaldec_type,
  CHK_globaldef_export,
  CHK_id_name,
  CHK_int_value,
  CHK_monop_op,
  CHK_param_type,
  CHK_program_symboltable,
  CHK_symboltable_parent,
  CHK_symboltableentry_name,
  CHK_vardec_type,
} attr_list;
