
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node *
MakeEmptyNode ()
{
  node *result;

  DBUG_ENTER ("MakeEmptyNode");

  result = (node *) MEMmalloc (sizeof (node));

  NODE_LINE (result) = global.line;
  NODE_COL (result) = global.col;

  DBUG_RETURN (result);
}



/*****************************************************************************
 * N_Program :
 *****************************************************************************/

node *
TBmakeProgram (node * Declarations)
{
  node *this;
  DBUG_ENTER ("TBmakeProgram");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_program = MEMmalloc (sizeof (struct SONS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_program = MEMmalloc (sizeof (struct ATTRIBS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declarations initial value: %s ",
	       Declarations));
  PROGRAM_DECLARATIONS (this) = Declarations;
  PROGRAM_SYMBOLTABLE (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PROGRAM_DECLARATIONS (this) != NULL)
      && (NODE_TYPE (PROGRAM_DECLARATIONS (this)) != N_declarations))
    {
      CTIwarn
	("Field Declarations of node N_Program has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Declarations :
 *****************************************************************************/

node *
TBmakeDeclarations (node * Declaration, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeDeclarations");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_declarations;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_declarations = MEMmalloc (sizeof (struct SONS_N_DECLARATIONS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_declarations =
    MEMmalloc (sizeof (struct ATTRIBS_N_DECLARATIONS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_declarations;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declaration initial value: %s ", Declaration));
  DECLARATIONS_DECLARATION (this) = Declaration;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  DECLARATIONS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DECLARATIONS_DECLARATION (this) != NULL)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_fundec)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_fundef)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_globaldec)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_globaldef))
    {
      CTIwarn
	("Field Declaration of node N_Declarations has non-allowed target node.");
    }
  if ((DECLARATIONS_NEXT (this) != NULL)
      && (NODE_TYPE (DECLARATIONS_NEXT (this)) != N_declarations))
    {
      CTIwarn
	("Field Next of node N_Declarations has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDec :
 *****************************************************************************/

node *
TBmakeFundec (node * FunHeader)
{
  node *this;
  DBUG_ENTER ("TBmakeFundec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundec = MEMmalloc (sizeof (struct SONS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundec = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEC_FUNHEADER (this) = FunHeader;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEC_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEC_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDef :
 *****************************************************************************/

node *
TBmakeFundef (bool Export, node * FunHeader, node * FunBody, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeFundef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundef = MEMmalloc (sizeof (struct SONS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundef = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEF_FUNHEADER (this) = FunHeader;
  DBUG_PRINT ("MAKE", ("assigning son FunBody initial value: %s ", FunBody));
  FUNDEF_FUNBODY (this) = FunBody;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  FUNDEF_NEXT (this) = Next;
  FUNDEF_EXPORT (this) = Export;
  FUNDEF_SYMBOLTABLE (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEF_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_FUNBODY (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNBODY (this)) != N_funbody))
    {
      CTIwarn ("Field FunBody of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_NEXT (this) != NULL)
      && (NODE_TYPE (FUNDEF_NEXT (this)) != N_fundef)
      && (NODE_TYPE (FUNDEF_NEXT (this)) != N_vardec))
    {
      CTIwarn ("Field Next of node N_FunDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunHeader :
 *****************************************************************************/

node *
TBmakeFunheader (char *Name, basictype RetType, node * Params)
{
  node *this;
  DBUG_ENTER ("TBmakeFunheader");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funheader = MEMmalloc (sizeof (struct SONS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funheader = MEMmalloc (sizeof (struct ATTRIBS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  FUNHEADER_PARAMS (this) = Params;
  FUNHEADER_NAME (this) = Name;
  FUNHEADER_RETTYPE (this) = RetType;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNHEADER_PARAMS (this) != NULL)
      && (NODE_TYPE (FUNHEADER_PARAMS (this)) != N_param))
    {
      CTIwarn
	("Field Params of node N_FunHeader has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDec :
 *****************************************************************************/

node *
TBmakeGlobaldec (basictype Type, char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldec = MEMmalloc (sizeof (struct SONS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldec = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldec;
  GLOBALDEC_TYPE (this) = Type;
  GLOBALDEC_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDef :
 *****************************************************************************/

node *
TBmakeGlobaldef (bool Export, basictype Type, char *Name, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldef = MEMmalloc (sizeof (struct SONS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldef = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  GLOBALDEF_EXPR (this) = Expr;
  GLOBALDEF_EXPORT (this) = Export;
  GLOBALDEF_TYPE (this) = Type;
  GLOBALDEF_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBALDEF_EXPR (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_binop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_monop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_cast)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_id)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_funcall)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_int)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_float)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_bool)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_GlobalDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Param :
 *****************************************************************************/

node *
TBmakeParam (basictype Type, char *Name, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeParam");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_param = MEMmalloc (sizeof (struct SONS_N_PARAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_param = MEMmalloc (sizeof (struct ATTRIBS_N_PARAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  PARAM_NEXT (this) = Next;
  PARAM_TYPE (this) = Type;
  PARAM_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAM_NEXT (this) != NULL)
      && (NODE_TYPE (PARAM_NEXT (this)) != N_param))
    {
      CTIwarn ("Field Next of node N_Param has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Block :
 *****************************************************************************/

node *
TBmakeBlock (node * Statements)
{
  node *this;
  DBUG_ENTER ("TBmakeBlock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_block;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_block = MEMmalloc (sizeof (struct SONS_N_BLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_block = MEMmalloc (sizeof (struct ATTRIBS_N_BLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_block;
  DBUG_PRINT ("MAKE",
	      ("assigning son Statements initial value: %s ", Statements));
  BLOCK_STATEMENTS (this) = Statements;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BLOCK_STATEMENTS (this) != NULL)
      && (NODE_TYPE (BLOCK_STATEMENTS (this)) != N_statements))
    {
      CTIwarn
	("Field Statements of node N_Block has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunBody :
 *****************************************************************************/

node *
TBmakeFunbody (node * LocalFunVars, node * Statements)
{
  node *this;
  DBUG_ENTER ("TBmakeFunbody");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funbody = MEMmalloc (sizeof (struct SONS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funbody = MEMmalloc (sizeof (struct ATTRIBS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE",
	      ("assigning son LocalFunVars initial value: %s ",
	       LocalFunVars));
  FUNBODY_LOCALFUNVARS (this) = LocalFunVars;
  DBUG_PRINT ("MAKE",
	      ("assigning son Statements initial value: %s ", Statements));
  FUNBODY_STATEMENTS (this) = Statements;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNBODY_LOCALFUNVARS (this) != NULL)
      && (NODE_TYPE (FUNBODY_LOCALFUNVARS (this)) != N_fundef)
      && (NODE_TYPE (FUNBODY_LOCALFUNVARS (this)) != N_vardec))
    {
      CTIwarn
	("Field LocalFunVars of node N_FunBody has non-allowed target node.");
    }
  if ((FUNBODY_STATEMENTS (this) != NULL)
      && (NODE_TYPE (FUNBODY_STATEMENTS (this)) != N_statements))
    {
      CTIwarn
	("Field Statements of node N_FunBody has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarDec :
 *****************************************************************************/

node *
TBmakeVardec (basictype Type, char *Name, node * Expr, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeVardec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_vardec = MEMmalloc (sizeof (struct SONS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_vardec = MEMmalloc (sizeof (struct ATTRIBS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  VARDEC_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  VARDEC_NEXT (this) = Next;
  VARDEC_TYPE (this) = Type;
  VARDEC_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARDEC_EXPR (this) != NULL)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_binop)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_monop)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_cast)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_id)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_funcall)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_int)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_float)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_bool)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_VarDec has non-allowed target node.");
    }
  if ((VARDEC_NEXT (this) != NULL)
      && (NODE_TYPE (VARDEC_NEXT (this)) != N_fundef)
      && (NODE_TYPE (VARDEC_NEXT (this)) != N_vardec))
    {
      CTIwarn ("Field Next of node N_VarDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Statements :
 *****************************************************************************/

node *
TBmakeStatements (node * Statement, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeStatements");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_statements;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_statements = MEMmalloc (sizeof (struct SONS_N_STATEMENTS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_statements =
    MEMmalloc (sizeof (struct ATTRIBS_N_STATEMENTS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_statements;
  DBUG_PRINT ("MAKE",
	      ("assigning son Statement initial value: %s ", Statement));
  STATEMENTS_STATEMENT (this) = Statement;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  STATEMENTS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((STATEMENTS_STATEMENT (this) != NULL)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_assign)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_funcall)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_ifelse)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_while)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_dowhile)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_for)
      && (NODE_TYPE (STATEMENTS_STATEMENT (this)) != N_return))
    {
      CTIwarn
	("Field Statement of node N_Statements has non-allowed target node.");
    }
  if ((STATEMENTS_NEXT (this) != NULL)
      && (NODE_TYPE (STATEMENTS_NEXT (this)) != N_statements))
    {
      CTIwarn
	("Field Next of node N_Statements has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node *
TBmakeAssign (node * Expr, node * Id)
{
  node *this;
  DBUG_ENTER ("TBmakeAssign");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_assign = MEMmalloc (sizeof (struct SONS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_assign = MEMmalloc (sizeof (struct ATTRIBS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  ASSIGN_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Id initial value: %s ", Id));
  ASSIGN_ID (this) = Id;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ASSIGN_EXPR (this) != NULL)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_binop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_monop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_cast)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_id)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_funcall)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_int)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_float)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_bool)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_Assign has non-allowed target node.");
    }
  if ((ASSIGN_ID (this) != NULL) && (NODE_TYPE (ASSIGN_ID (this)) != N_id))
    {
      CTIwarn ("Field Id of node N_Assign has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_IfElse :
 *****************************************************************************/

node *
TBmakeIfelse (node * IfExpr, node * IfBlock, node * ElseBlock)
{
  node *this;
  DBUG_ENTER ("TBmakeIfelse");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ifelse;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ifelse = MEMmalloc (sizeof (struct SONS_N_IFELSE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ifelse = MEMmalloc (sizeof (struct ATTRIBS_N_IFELSE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ifelse;
  DBUG_PRINT ("MAKE", ("assigning son IfExpr initial value: %s ", IfExpr));
  IFELSE_IFEXPR (this) = IfExpr;
  DBUG_PRINT ("MAKE", ("assigning son IfBlock initial value: %s ", IfBlock));
  IFELSE_IFBLOCK (this) = IfBlock;
  DBUG_PRINT ("MAKE",
	      ("assigning son ElseBlock initial value: %s ", ElseBlock));
  IFELSE_ELSEBLOCK (this) = ElseBlock;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((IFELSE_IFEXPR (this) != NULL)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_binop)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_monop)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_cast)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_id)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_funcall)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_int)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_float)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_bool)
      && (NODE_TYPE (IFELSE_IFEXPR (this)) != N_ternary))
    {
      CTIwarn ("Field IfExpr of node N_IfElse has non-allowed target node.");
    }
  if ((IFELSE_IFBLOCK (this) != NULL)
      && (NODE_TYPE (IFELSE_IFBLOCK (this)) != N_block))
    {
      CTIwarn ("Field IfBlock of node N_IfElse has non-allowed target node.");
    }
  if ((IFELSE_ELSEBLOCK (this) != NULL)
      && (NODE_TYPE (IFELSE_ELSEBLOCK (this)) != N_block))
    {
      CTIwarn
	("Field ElseBlock of node N_IfElse has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_While :
 *****************************************************************************/

node *
TBmakeWhile (node * Expr, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeWhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_while = MEMmalloc (sizeof (struct SONS_N_WHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_while = MEMmalloc (sizeof (struct ATTRIBS_N_WHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  WHILE_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  WHILE_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((WHILE_EXPR (this) != NULL)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_binop)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_monop)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_cast)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_id)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_funcall)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_int)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_float)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_bool)
      && (NODE_TYPE (WHILE_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_While has non-allowed target node.");
    }
  if ((WHILE_BLOCK (this) != NULL)
      && (NODE_TYPE (WHILE_BLOCK (this)) != N_block))
    {
      CTIwarn ("Field Block of node N_While has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_DoWhile :
 *****************************************************************************/

node *
TBmakeDowhile (node * Expr, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeDowhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_dowhile = MEMmalloc (sizeof (struct SONS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_dowhile = MEMmalloc (sizeof (struct ATTRIBS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  DOWHILE_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  DOWHILE_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DOWHILE_EXPR (this) != NULL)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_binop)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_monop)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_cast)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_id)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_funcall)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_int)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_float)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_bool)
      && (NODE_TYPE (DOWHILE_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_DoWhile has non-allowed target node.");
    }
  if ((DOWHILE_BLOCK (this) != NULL)
      && (NODE_TYPE (DOWHILE_BLOCK (this)) != N_block))
    {
      CTIwarn ("Field Block of node N_DoWhile has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_For :
 *****************************************************************************/

node *
TBmakeFor (char *CounterName, node * StartExpr, node * EndExpr,
	   node * StepExpr, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeFor");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_for = MEMmalloc (sizeof (struct SONS_N_FOR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_for = MEMmalloc (sizeof (struct ATTRIBS_N_FOR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE",
	      ("assigning son StartExpr initial value: %s ", StartExpr));
  FOR_STARTEXPR (this) = StartExpr;
  DBUG_PRINT ("MAKE", ("assigning son EndExpr initial value: %s ", EndExpr));
  FOR_ENDEXPR (this) = EndExpr;
  DBUG_PRINT ("MAKE",
	      ("assigning son StepExpr initial value: %s ", StepExpr));
  FOR_STEPEXPR (this) = StepExpr;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  FOR_BLOCK (this) = Block;
  FOR_COUNTERNAME (this) = CounterName;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FOR_STARTEXPR (this) != NULL)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_binop)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_monop)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_cast)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_id)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_funcall)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_int)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_float)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_bool)
      && (NODE_TYPE (FOR_STARTEXPR (this)) != N_ternary))
    {
      CTIwarn ("Field StartExpr of node N_For has non-allowed target node.");
    }
  if ((FOR_ENDEXPR (this) != NULL)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_binop)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_monop)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_cast)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_id)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_funcall)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_int)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_float)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_bool)
      && (NODE_TYPE (FOR_ENDEXPR (this)) != N_ternary))
    {
      CTIwarn ("Field EndExpr of node N_For has non-allowed target node.");
    }
  if ((FOR_STEPEXPR (this) != NULL)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_binop)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_monop)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_cast)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_id)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_funcall)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_int)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_float)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_bool)
      && (NODE_TYPE (FOR_STEPEXPR (this)) != N_ternary))
    {
      CTIwarn ("Field StepExpr of node N_For has non-allowed target node.");
    }
  if ((FOR_BLOCK (this) != NULL) && (NODE_TYPE (FOR_BLOCK (this)) != N_block))
    {
      CTIwarn ("Field Block of node N_For has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Return :
 *****************************************************************************/

node *
TBmakeReturn (node * RetValue)
{
  node *this;
  DBUG_ENTER ("TBmakeReturn");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_return = MEMmalloc (sizeof (struct SONS_N_RETURN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_return = MEMmalloc (sizeof (struct ATTRIBS_N_RETURN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE",
	      ("assigning son RetValue initial value: %s ", RetValue));
  RETURN_RETVALUE (this) = RetValue;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((RETURN_RETVALUE (this) != NULL)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_binop)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_monop)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_cast)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_id)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_funcall)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_int)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_float)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_bool)
      && (NODE_TYPE (RETURN_RETVALUE (this)) != N_ternary))
    {
      CTIwarn
	("Field RetValue of node N_Return has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Exprs :
 *****************************************************************************/

node *
TBmakeExprs (node * Expr, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeExprs");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_exprs;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_exprs = MEMmalloc (sizeof (struct SONS_N_EXPRS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_exprs = MEMmalloc (sizeof (struct ATTRIBS_N_EXPRS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_exprs;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  EXPRS_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  EXPRS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((EXPRS_EXPR (this) != NULL)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_binop)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_monop)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_cast)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_id)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_funcall)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_int)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_float)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_bool)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_Exprs has non-allowed target node.");
    }
  if ((EXPRS_NEXT (this) != NULL)
      && (NODE_TYPE (EXPRS_NEXT (this)) != N_exprs))
    {
      CTIwarn ("Field Next of node N_Exprs has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node *
TBmakeBinop (binop Op, node * Left, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeBinop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_binop = MEMmalloc (sizeof (struct SONS_N_BINOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_binop = MEMmalloc (sizeof (struct ATTRIBS_N_BINOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("assigning son Left initial value: %s ", Left));
  BINOP_LEFT (this) = Left;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  BINOP_RIGHT (this) = Right;
  BINOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BINOP_LEFT (this) != NULL)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_binop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_monop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_cast)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_id)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_int)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_float)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_bool)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_ternary))
    {
      CTIwarn ("Field Left of node N_BinOp has non-allowed target node.");
    }
  if ((BINOP_RIGHT (this) != NULL)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_cast)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_id)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_int)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_float)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_bool)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_ternary))
    {
      CTIwarn ("Field Right of node N_BinOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node *
TBmakeMonop (monop Op, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeMonop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_monop = MEMmalloc (sizeof (struct SONS_N_MONOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_monop = MEMmalloc (sizeof (struct ATTRIBS_N_MONOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  MONOP_EXPR (this) = Expr;
  MONOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MONOP_EXPR (this) != NULL)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_binop)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_monop)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_cast)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_id)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_funcall)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_int)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_float)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_bool)
      && (NODE_TYPE (MONOP_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_MonOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Cast :
 *****************************************************************************/

node *
TBmakeCast (basictype Type, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeCast");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_cast = MEMmalloc (sizeof (struct SONS_N_CAST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_cast = MEMmalloc (sizeof (struct ATTRIBS_N_CAST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  CAST_EXPR (this) = Expr;
  CAST_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((CAST_EXPR (this) != NULL) && (NODE_TYPE (CAST_EXPR (this)) != N_binop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_monop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_cast)
      && (NODE_TYPE (CAST_EXPR (this)) != N_id)
      && (NODE_TYPE (CAST_EXPR (this)) != N_funcall)
      && (NODE_TYPE (CAST_EXPR (this)) != N_int)
      && (NODE_TYPE (CAST_EXPR (this)) != N_float)
      && (NODE_TYPE (CAST_EXPR (this)) != N_bool)
      && (NODE_TYPE (CAST_EXPR (this)) != N_ternary))
    {
      CTIwarn ("Field Expr of node N_Cast has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunCall :
 *****************************************************************************/

node *
TBmakeFuncall (char *Name, node * Params)
{
  node *this;
  DBUG_ENTER ("TBmakeFuncall");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funcall = MEMmalloc (sizeof (struct SONS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funcall = MEMmalloc (sizeof (struct ATTRIBS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  FUNCALL_PARAMS (this) = Params;
  FUNCALL_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNCALL_PARAMS (this) != NULL)
      && (NODE_TYPE (FUNCALL_PARAMS (this)) != N_exprs))
    {
      CTIwarn ("Field Params of node N_FunCall has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Id :
 *****************************************************************************/

node *
TBmakeId (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeId");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_id;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_id = MEMmalloc (sizeof (struct SONS_N_ID));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_id = MEMmalloc (sizeof (struct ATTRIBS_N_ID));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_id;
  ID_NAME (this) = Name;
  ID_SYMBOLTABLE (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Int :
 *****************************************************************************/

node *
TBmakeInt (int Value)
{
  node *this;
  DBUG_ENTER ("TBmakeInt");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_int;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_int = MEMmalloc (sizeof (struct SONS_N_INT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_int = MEMmalloc (sizeof (struct ATTRIBS_N_INT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_int;
  INT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Float :
 *****************************************************************************/

node *
TBmakeFloat (float Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFloat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_float;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_float = MEMmalloc (sizeof (struct SONS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_float = MEMmalloc (sizeof (struct ATTRIBS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_float;
  FLOAT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Ternary :
 *****************************************************************************/

node *
TBmakeTernary (node * Pred, node * Then, node * Else)
{
  node *this;
  DBUG_ENTER ("TBmakeTernary");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ternary;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ternary = MEMmalloc (sizeof (struct SONS_N_TERNARY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ternary = MEMmalloc (sizeof (struct ATTRIBS_N_TERNARY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ternary;
  DBUG_PRINT ("MAKE", ("assigning son Pred initial value: %s ", Pred));
  TERNARY_PRED (this) = Pred;
  DBUG_PRINT ("MAKE", ("assigning son Then initial value: %s ", Then));
  TERNARY_THEN (this) = Then;
  DBUG_PRINT ("MAKE", ("assigning son Else initial value: %s ", Else));
  TERNARY_ELSE (this) = Else;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((TERNARY_PRED (this) != NULL)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_binop)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_monop)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_cast)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_id)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_funcall)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_int)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_float)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_bool)
      && (NODE_TYPE (TERNARY_PRED (this)) != N_ternary))
    {
      CTIwarn ("Field Pred of node N_Ternary has non-allowed target node.");
    }
  if ((TERNARY_THEN (this) != NULL)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_binop)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_monop)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_cast)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_id)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_funcall)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_int)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_float)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_bool)
      && (NODE_TYPE (TERNARY_THEN (this)) != N_ternary))
    {
      CTIwarn ("Field Then of node N_Ternary has non-allowed target node.");
    }
  if ((TERNARY_ELSE (this) != NULL)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_binop)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_monop)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_cast)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_id)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_funcall)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_int)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_float)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_bool)
      && (NODE_TYPE (TERNARY_ELSE (this)) != N_ternary))
    {
      CTIwarn ("Field Else of node N_Ternary has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Bool :
 *****************************************************************************/

node *
TBmakeBool (bool Value)
{
  node *this;
  DBUG_ENTER ("TBmakeBool");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_bool;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_bool = MEMmalloc (sizeof (struct SONS_N_BOOL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_bool = MEMmalloc (sizeof (struct ATTRIBS_N_BOOL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_bool;
  BOOL_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_SymbolTable :
 *****************************************************************************/

node *
TBmakeSymboltable (node * Parent, node * Entries)
{
  node *this;
  DBUG_ENTER ("TBmakeSymboltable");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_symboltable;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_symboltable = MEMmalloc (sizeof (struct SONS_N_SYMBOLTABLE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_symboltable =
    MEMmalloc (sizeof (struct ATTRIBS_N_SYMBOLTABLE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_symboltable;
  DBUG_PRINT ("MAKE", ("assigning son Entries initial value: %s ", Entries));
  SYMBOLTABLE_ENTRIES (this) = Entries;
  SYMBOLTABLE_PARENT (this) = Parent;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((SYMBOLTABLE_ENTRIES (this) != NULL)
      && (NODE_TYPE (SYMBOLTABLE_ENTRIES (this)) != N_symboltableentry))
    {
      CTIwarn
	("Field Entries of node N_SymbolTable has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_SymbolTableEntry :
 *****************************************************************************/

node *
TBmakeSymboltableentry (char *Name, basictype Type, bool IsFunction,
			bool import, bool Export, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeSymboltableentry");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_symboltableentry;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_symboltableentry =
    MEMmalloc (sizeof (struct SONS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_symboltableentry =
    MEMmalloc (sizeof (struct ATTRIBS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_symboltableentry;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  SYMBOLTABLEENTRY_NEXT (this) = Next;
  SYMBOLTABLEENTRY_NAME (this) = Name;
  SYMBOLTABLEENTRY_TYPE (this) = Type;
  SYMBOLTABLEENTRY_PARAMS (this) = NULL;
  SYMBOLTABLEENTRY_ISFUNCTION (this) = IsFunction;
  SYMBOLTABLEENTRY_IMPORT (this) = import;
  SYMBOLTABLEENTRY_EXPORT (this) = Export;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((SYMBOLTABLEENTRY_NEXT (this) != NULL)
      && (NODE_TYPE (SYMBOLTABLEENTRY_NEXT (this)) != N_symboltableentry))
    {
      CTIwarn
	("Field Next of node N_SymbolTableEntry has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Error :
 *****************************************************************************/

node *
TBmakeError (char *message, compiler_phase_t anyphase, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeError");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_error = MEMmalloc (sizeof (struct SONS_N_ERROR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_error = MEMmalloc (sizeof (struct ATTRIBS_N_ERROR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  ERROR_NEXT (this) = Next;
  ERROR_MESSAGE (this) = message;
  ERROR_ANYPHASE (this) = anyphase;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ERROR_NEXT (this) != NULL)
      && (NODE_TYPE (ERROR_NEXT (this)) != N_error))
    {
      CTIwarn ("Field Next of node N_Error has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

  /* end of file */
